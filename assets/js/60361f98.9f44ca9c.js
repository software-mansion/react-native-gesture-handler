"use strict";(self.webpackChunkreact_native_gesture_handler_docs=self.webpackChunkreact_native_gesture_handler_docs||[]).push([[1708],{4462:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>h,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>x});const r=JSON.parse('{"id":"guides/upgrading-to-3","title":"Upgrading to the new API introduced in Gesture Handler 3","description":"Migrating gestures","source":"@site/docs/guides/upgrading-to-3.mdx","sourceDirName":"guides","slug":"/guides/upgrading-to-3","permalink":"/react-native-gesture-handler/docs/guides/upgrading-to-3","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-gesture-handler/edit/main/docs/docs/guides/upgrading-to-3.mdx","tags":[],"version":"current","frontMatter":{"id":"upgrading-to-3","title":"Upgrading to the new API introduced in Gesture Handler 3"},"sidebar":"tutorialSidebar","previous":{"title":"Custom swipeable components inside ScrollView (web)","permalink":"/react-native-gesture-handler/docs/guides/swipe-and-scroll"},"next":{"title":"Gestures","permalink":"/react-native-gesture-handler/docs/category/gestures"}}');var t=n(4848),c=n(8453),d=n(8069),i=n(9146);function l({label1:e,label2:s,code1:n,code2:r,skipFormatting1:c=!1,skipFormatting2:l=!1}){const o=(0,i.A)(c?"":n),a=(0,i.A)(l?"":r);return(0,t.jsxs)("div",{className:"codeComparison",children:[(0,t.jsxs)("div",{className:"codeHolder",children:[(0,t.jsx)("div",{className:"codeComparisonHeader",children:e}),(0,t.jsx)(d.A,{language:"tsx",children:c?n:o})]}),(0,t.jsxs)("div",{className:"codeHolder",children:[(0,t.jsx)("div",{className:"codeComparisonHeader",children:s}),(0,t.jsx)(d.A,{language:"tsx",children:l?r:a})]})]})}const o={id:"upgrading-to-3",title:"Upgrading to the new API introduced in Gesture Handler 3"},a=void 0,h={},x=[{value:"Migrating gestures",id:"migrating-gestures",level:2},{value:"Renamed callbacks",id:"renamed-callbacks",level:3},{value:"onChange",id:"onchange",level:3},{value:"state &amp; oldState",id:"state--oldstate",level:3},{value:"Event types",id:"event-types",level:3},{value:"StateManager",id:"statemanager",level:3},{value:"Migrating relations",id:"migrating-relations",level:2},{value:"Composed gestures",id:"composed-gestures",level:3},{value:"Cross components relations properties",id:"cross-components-relations-properties",level:3},{value:"Migrating components relying on view hierarchy",id:"migrating-components-relying-on-view-hierarchy",level:2},{value:"Migrating SVG",id:"migrating-svg",level:3},{value:"Old components",id:"old-components",level:2},{value:"Buttons",id:"buttons",level:3},{value:"Other components",id:"other-components",level:3},{value:"Replaced types",id:"replaced-types",level:2}];function j(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,c.R)(),...e.components},{Details:n}=s;return n||function(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h2,{id:"migrating-gestures",children:"Migrating gestures"}),"\n","\n",(0,t.jsx)(s.p,{children:"The most important change brought by the Gesture Handler 3 is the new hook API. Migration is pretty straightforward. Instead of calling builder methods, everything is passed as a configuration object."}),"\n",(0,t.jsx)(l,{label1:"RNGH 2",label2:"RNGH 3",code1:"const gesture = Gesture.Pan()\n.onBegin(() => {\n  console.log('Pan!');\n})\n.minDistance(25);\n",code2:"const gesture = usePanGesture({\n    onBegin: () => {\n      console.log('Pan!');\n    },\n    minDistance: 25,\n  });\n"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.a,{href:"/docs/2.x/gestures/force-touch-gesture",children:(0,t.jsx)(s.code,{children:"ForceTouch"})})," gesture is not available in hook API."]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"Full changes"}),(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"RNGH2"}),(0,t.jsx)(s.th,{children:"RNGH3"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Pan()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"usePanGesture()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Tap()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"useTapGesture()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.LongPress()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"useLongPressGesture()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Rotation()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"useRotationGesture()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Pinch()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"usePinchGesture()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Fling()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"useFlingGesture()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Hover()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"useHoverGesture()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Native()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"useNativeGesture()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Manual()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"useManualGesture()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.ForceTouch()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.em,{children:"Not available in hook API"})})]})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"renamed-callbacks",children:"Renamed callbacks"}),"\n",(0,t.jsx)(s.p,{children:"In Gesture Handler 3 some of the callbacks were renamed, namely:"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"RNGH2"}),(0,t.jsx)(s.th,{children:"RNGH3"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"onStart"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"onActivate"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"onEnd"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"onDeactivate"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"onTouchesCancelled"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"onTouchesCancel"})})]})]})]}),"\n",(0,t.jsx)(s.p,{children:"Here is comparison of the two APIs:"}),"\n",(0,t.jsx)(l,{label1:"RNGH 2",label2:"RNGH 3",code1:"const gesture = Gesture.Pan()\n.onStart(() => {\n  console.log('Pan started!');\n})\n.onEnd(() => {\n  console.log('Pan ended!');\n})\n.onTouchesCancelled(() => {\n  console.log('Pan touches cancelled!');\n});\n",code2:"const gesture = usePanGesture({\nonActivate: () => {\n  console.log('Pan activated!');\n},\nonDeactivate: () => {\n  console.log('Pan deactivated!');\n},\nonTouchesCancel: () => {\n  console.log('Pan touches cancelled!');\n},\n});\n"}),"\n",(0,t.jsx)(s.h3,{id:"onchange",children:"onChange"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"onChange"})," callback has been removed, and its functionality has been integrated into ",(0,t.jsx)(s.code,{children:"onUpdate"}),". You can now access ",(0,t.jsx)(s.code,{children:"change*"})," properties in ",(0,t.jsx)(s.code,{children:"onUpdate"})," callback."]}),"\n",(0,t.jsx)(l,{label1:"RNGH 2",label2:"RNGH 3",code1:"const pan = Gesture.Pan().onChange((e) => {\nconsole.log(e.changeX);\n});\n",code2:"const pan = usePanGesture({\nonUpdate: (e) => {\n  console.log(e.changeX);\n},\n});\n"}),"\n",(0,t.jsx)(s.h3,{id:"state--oldstate",children:"state & oldState"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"state"})," and ",(0,t.jsx)(s.code,{children:"oldState"})," properties are no longer available in event objects. Tracking state changes can now only be accomplished using the appropriate ",(0,t.jsx)(s.a,{href:"/docs/fundamentals/callbacks-events",children:"callbacks"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"event-types",children:"Event types"}),"\n",(0,t.jsxs)(s.p,{children:["The types of events have been unified for all callbacks. Each event falls into one of two categories: ",(0,t.jsx)(s.a,{href:"/docs/fundamentals/callbacks-events#gestureevent",children:(0,t.jsx)(s.code,{children:"GestureEvent"})})," for gesture callbacks, or ",(0,t.jsx)(s.a,{href:"/docs/fundamentals/callbacks-events#touchevent",children:(0,t.jsx)(s.code,{children:"GestureTouchEvent"})})," for ",(0,t.jsx)(s.code,{children:"TouchEvent"})," callbacks."]}),"\n",(0,t.jsx)(s.h3,{id:"statemanager",children:"StateManager"}),"\n",(0,t.jsxs)(s.p,{children:["In Gesture Handler 3, ",(0,t.jsx)(s.code,{children:"stateManager"})," is no longer passed to ",(0,t.jsx)(s.code,{children:"TouchEvent"})," callbacks. Instead, you should use the global ",(0,t.jsx)(s.a,{href:"/docs/fundamentals/state-manager",children:(0,t.jsx)(s.code,{children:"GestureStateManager"})}),"."]}),"\n",(0,t.jsx)(l,{label1:"RNGH 2",label2:"RNGH 3",code1:"const manual = Gesture.Manual().onTouchesDown((e, stateManager ) => {\nstateManager.activate();\n});\n",code2:"const manual = useManualGesture({\nonTouchesDown: (e) => {\n  GestureStateManager.activate(e.handlerTag);\n},\n});\n"}),"\n",(0,t.jsx)(s.h2,{id:"migrating-relations",children:"Migrating relations"}),"\n",(0,t.jsx)(s.h3,{id:"composed-gestures",children:"Composed gestures"}),"\n",(0,t.jsxs)(s.p,{children:["Previously, composed gestures were created using ",(0,t.jsx)(s.code,{children:"Gesture"})," object. In Gesture Handler 3, relations are set up using relation hooks."]}),"\n",(0,t.jsx)(l,{label1:"RNGH 2",label2:"RNGH 3",code1:"const pan1 = Gesture.Pan();\nconst pan2 = Gesture.Pan();\n\nconst gesture = Gesture.Simultaneous(pan1, pan2);\n",code2:"const pan1 = usePanGesture({});\nconst pan2 = usePanGesture({});\n\nconst gesture = useSimultaneousGestures(pan1, pan2);\n"}),"\n",(0,t.jsx)(s.p,{children:"Full changes are as follows:"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"RNGH2"}),(0,t.jsx)(s.th,{children:"RNGH3"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Race()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"useCompetingGestures()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Simultaneous()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"useSimultaneousGestures()"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Gesture.Exclusive()"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"useExclusiveGestures()"})})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"cross-components-relations-properties",children:"Cross components relations properties"}),"\n",(0,t.jsx)(s.p,{children:"Properties used to define cross-components interactions were renamed."}),"\n",(0,t.jsx)(l,{label1:"RNGH 2",label2:"RNGH 3",code1:"const pan1 = Gesture.Pan();\nconst pan2 =\n  Gesture.Pan().requireExternalGestureToFail(pan1);\n",code2:"const pan1 = usePanGesture({});\nconst pan2 = usePanGesture({\nrequireToFail: pan1,\n});\n"}),"\n",(0,t.jsx)(s.p,{children:"Full changes are as follows:"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"RNGH2"}),(0,t.jsx)(s.th,{children:"RNGH3"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"gesture.simultaneousWithExternalGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"gesture.simultaneousWith"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"gesture.requireExternalGestureToFail"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"gesture.requireToFail"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"gesture.blocksExternalGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"gesture.block"})})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"migrating-components-relying-on-view-hierarchy",children:"Migrating components relying on view hierarchy"}),"\n",(0,t.jsxs)(s.p,{children:["Certain components, such as ",(0,t.jsx)(s.code,{children:"SVG"}),", depend on the view hierarchy to function correctly. In Gesture Handler 3, ",(0,t.jsx)(s.code,{children:"GestureDetector"})," disrupts these hierarchies. To resolve this issue, two new detectors have been introduced: ",(0,t.jsx)(s.a,{href:"/docs/fundamentals/gesture-detectors#interceptinggesturedetector",children:(0,t.jsx)(s.code,{children:"InterceptingGestureDetector"})})," and ",(0,t.jsx)(s.a,{href:"/docs/fundamentals/gesture-detectors#virtualgesturedetector",children:(0,t.jsx)(s.code,{children:"VirtualGestureDetector"})}),"."]}),"\n",(0,t.jsx)(s.admonition,{title:"Detectors order",type:"danger",children:(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"VirtualGestureDetector"})," has to be a descendant of ",(0,t.jsx)(s.code,{children:"InterceptingGestureDetector"}),"."]})}),"\n",(0,t.jsx)(s.h3,{id:"migrating-svg",children:"Migrating SVG"}),"\n",(0,t.jsxs)(s.p,{children:["In Gesture Handler 2 it was possible to use ",(0,t.jsx)(s.code,{children:"GestureDetector"})," directly on ",(0,t.jsx)(s.code,{children:"SVG"}),". In Gesture Handler 3, the correct way to interact with ",(0,t.jsx)(s.code,{children:"SVG"})," is to use ",(0,t.jsx)(s.code,{children:"InterceptingGestureDetector"})," and ",(0,t.jsx)(s.code,{children:"VirtualGestureDetector"}),"."]}),"\n",(0,t.jsx)(l,{label1:"RNGH 2",label2:"RNGH 3",code1:"\n<GestureDetector gesture={containerTap}>\n<Svg>\n  <GestureDetector gesture={circleTap}>\n    <Circle />\n  </GestureDetector>\n</Svg>\n</GestureDetector>\n",code2:"\n<InterceptingGestureDetector gesture={containerTap}>\n<Svg>\n  <VirtualGestureDetector gesture={circleTap}>\n    <Circle />\n  </VirtualGestureDetector>\n</Svg>\n</InterceptingGestureDetector>\n"}),"\n",(0,t.jsx)(s.h2,{id:"old-components",children:"Old components"}),"\n",(0,t.jsx)(s.h3,{id:"buttons",children:"Buttons"}),"\n",(0,t.jsxs)(s.p,{children:["The implementation of buttons has been updated, resolving most button-related issues. They have also been internally rewritten to utilize the new hook API. The original button components are still accessible but have been renamed with the prefix ",(0,t.jsx)(s.code,{children:"Legacy"}),", e.g., ",(0,t.jsx)(s.code,{children:"RectButton"})," is now available as ",(0,t.jsx)(s.code,{children:"LegacyRectButton"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"Although the legacy JS implementation of the buttons is still available, they also use the new host component internally."}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"Legacy buttons"}),(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"RNGH2"}),(0,t.jsx)(s.th,{children:"RNGH3"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"RawButton"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyRawButton"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"BaseButton"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyBaseButton"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"RectButton"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyRectButton"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"BorderlessButton"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyBorderlessButton"})})]})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"other-components",children:"Other components"}),"\n",(0,t.jsxs)(s.p,{children:["Other components have also been internally rewritten using the new hook API but are exported under their original names, so no changes are necessary on your part. However, if you need to use the previous implementation for any reason, the old components are also available and are prefixed with ",(0,t.jsx)(s.code,{children:"Legacy"}),", e.g., ",(0,t.jsx)(s.code,{children:"ScrollView"})," is now available as ",(0,t.jsx)(s.code,{children:"LegacyScrollView"}),"."]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"Legacy components"}),(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"RNGH2"}),(0,t.jsx)(s.th,{children:"RNGH3"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"ScrollView"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyScrollView"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"FlatList"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyFlatList"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"RefreshControl"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyRefreshControl"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Switch"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacySwitch"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"TextInput"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyTextInput"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"DrawerLayoutAndroid"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyDrawerLayoutAndroid"})})]})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"replaced-types",children:"Replaced types"}),"\n",(0,t.jsxs)(s.p,{children:["Most of the types, like ",(0,t.jsx)(s.code,{children:"TapGesture"}),", are still present in Gesture Handler 3. However, they are now used in new hook API. Types for old API now have ",(0,t.jsx)(s.code,{children:"Legacy"})," prefix, e.g. ",(0,t.jsx)(s.code,{children:"TapGesture"})," becomes ",(0,t.jsx)(s.code,{children:"LegacyTapGesture"}),"."]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:"Legacy types"}),(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"RNGH2"}),(0,t.jsx)(s.th,{children:"RNGH3"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"PanGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyPanGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"TapGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyTapGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LongPressGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyLongPressGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"RotationGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyRotationGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"PinchGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyPinchGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"FlingGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyFlingGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"HoverGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyHoverGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"NativeGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyNativeGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"ManualGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyManualGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"ForceTouchGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyForceTouchGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"ComposedGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyComposedGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"RaceGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyRaceGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"SimultaneousGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacySimultaneousGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"ExclusiveGesture"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyExclusiveGesture"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"RawButtonProps"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyRawButtonProps"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"BaseButtonProps"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyBaseButtonProps"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"RectButtonProps"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyRectButtonProps"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"BorderlessButtonProps"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LegacyBorderlessButtonProps"})})]})]})]})]})]})}function u(e={}){const{wrapper:s}={...(0,c.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(j,{...e})}):j(e)}},9146:(e,s,n)=>{n.d(s,{A:()=>l});var r=n(6540),t=n(8463),c=n(2396),d=n(6745);const i={parser:"typescript",plugins:[c.A,d.Ay]};function l(e){const[s,n]=(0,r.useState)(e);return(0,r.useEffect)((()=>{!async function(){try{const s=await t.GP(e,i);n(s)}catch{n(e)}}()}),[e]),s}}}]);