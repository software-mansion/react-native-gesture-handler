"use strict";(self.webpackChunkreact_native_gesture_handler_docs=self.webpackChunkreact_native_gesture_handler_docs||[]).push([[1301],{3492:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"fundamentals/gesture-composition","title":"Gesture composition & interactions","description":"RNGH3 simplifies gesture interaction through dedicated composition hooks and configuration properties. To choose the right approach, simply ask: Are all the gestures attached to the same component?","source":"@site/docs/fundamentals/gesture-composition.md","sourceDirName":"fundamentals","slug":"/fundamentals/gesture-composition","permalink":"/react-native-gesture-handler/docs/fundamentals/gesture-composition","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-gesture-handler/edit/main/docs/docs/fundamentals/gesture-composition.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"gesture-composition","title":"Gesture composition & interactions","sidebar_label":"Gesture composition & interactions","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Integration with Animated","permalink":"/react-native-gesture-handler/docs/fundamentals/animated-interactions"},"next":{"title":"State manager","permalink":"/react-native-gesture-handler/docs/fundamentals/state-manager"}}');var o=t(4848),r=t(8453);const a={id:"gesture-composition",title:"Gesture composition & interactions",sidebar_label:"Gesture composition & interactions",sidebar_position:6},i=void 0,l={},u=[{value:"Composition hooks",id:"composition-hooks",level:2},{value:"useCompetingGestures",id:"usecompetinggestures",level:3},{value:"useSimultaneousGestures",id:"usesimultaneousgestures",level:3},{value:"useExclusiveGestures",id:"useexclusivegestures",level:3},{value:"Cross-component interactions",id:"cross-component-interactions",level:2},{value:"requireToFail",id:"requiretofail",level:3},{value:"block",id:"block",level:3},{value:"simultaneousWith",id:"simultaneouswith",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"RNGH3 simplifies gesture interaction through dedicated composition hooks and configuration properties. To choose the right approach, simply ask: Are all the gestures attached to the same component?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"If yes: Use composition hooks. These allow you to bundle multiple gestures\u2014including previously composed ones\u2014into a single object for a GestureDetector."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"If no: Use relation properties to manually define how gestures interact. Since these properties also support composed gestures, you can mix both methods for more complex layouts."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"composition-hooks",children:"Composition hooks"}),"\n",(0,o.jsx)(n.h3,{id:"usecompetinggestures",children:"useCompetingGestures"}),"\n",(0,o.jsx)(n.p,{children:"Only one of the provided gestures can become active at the same time. The first gesture to become active will cancel the rest of the gestures. It accepts variable number of arguments."}),"\n",(0,o.jsxs)(n.p,{children:["For example, lets say that you have a component that you want to make draggable but you also want to show additional options on long press. Presumably you would not want the component to move after the long press activates. You can accomplish this using ",(0,o.jsx)(n.code,{children:"useCompetingGestures"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { View, StyleSheet } from 'react-native';\nimport {\n  GestureDetector,\n  usePanGesture,\n  useLongPressGesture,\n  GestureHandlerRootView,\n  useCompetingGestures,\n} from 'react-native-gesture-handler';\n\nexport default function App() {\n  const panGesture = usePanGesture({\n    onUpdate: () => {\n      console.log('Pan');\n    },\n  });\n  const longPressGesture = useLongPressGesture({\n    onDeactivate: (_, success) => {\n      if (success) {\n        console.log('Long Press');\n      }\n    },\n  });\n\n  const gesture = useCompetingGestures(panGesture, longPressGesture);\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={gesture}>\n        <View style={styles.box} />\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'space-around',\n  },\n  box: {\n    height: 120,\n    width: 120,\n    backgroundColor: '#b58df1',\n    borderRadius: 20,\n    marginBottom: 30,\n  },\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"usesimultaneousgestures",children:"useSimultaneousGestures"}),"\n",(0,o.jsx)(n.p,{children:"All of the provided gestures can activate at the same time. Activation of one will not cancel the other."}),"\n",(0,o.jsxs)(n.p,{children:["For example, if you want to make a gallery app, you might want user to be able to zoom, rotate and pan around photos. You can do it with ",(0,o.jsx)(n.code,{children:"useSimultaneousGestures"}),":"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Note: the ",(0,o.jsx)(n.code,{children:"useSharedValue"})," and ",(0,o.jsx)(n.code,{children:"useAnimatedStyle"})," are part of ",(0,o.jsx)(n.a,{href:"https://docs.swmansion.com/react-native-reanimated/",children:(0,o.jsx)(n.code,{children:"react-native-reanimated"})}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { StyleSheet } from 'react-native';\nimport {\n  GestureDetector,\n  GestureHandlerRootView,\n  usePanGesture,\n  usePinchGesture,\n  useRotationGesture,\n  useSimultaneousGestures,\n} from 'react-native-gesture-handler';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n} from 'react-native-reanimated';\n\nexport default function App() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n\n  const scale = useSharedValue(1);\n  const savedScale = useSharedValue(1);\n  const rotation = useSharedValue(0);\n  const savedRotation = useSharedValue(0);\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: scale.value },\n        { rotateZ: `${rotation.value}rad` },\n      ],\n    };\n  });\n\n  const dragGesture = usePanGesture({\n    averageTouches: true,\n    onUpdate: (e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    },\n    onDeactivate: () => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n    },\n  });\n\n  const zoomGesture = usePinchGesture({\n    onUpdate: (e) => {\n      scale.value = savedScale.value * e.scale;\n    },\n    onDeactivate: () => {\n      savedScale.value = scale.value;\n    },\n  });\n\n  const rotationGesture = useRotationGesture({\n    onUpdate: (e) => {\n      rotation.value = savedRotation.value + e.rotation;\n    },\n    onDeactivate: () => {\n      savedRotation.value = rotation.value;\n    },\n  });\n\n  const composedGesture = useSimultaneousGestures(\n    dragGesture,\n    zoomGesture,\n    rotationGesture\n  );\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={composedGesture}>\n        <Animated.View style={[styles.box, animatedStyles]} />\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'space-around',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n  },\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"useexclusivegestures",children:"useExclusiveGestures"}),"\n",(0,o.jsx)(n.p,{children:"Only one of the provided gestures can become active. Priority is determined by the order of the aguments, where the first gesture has the highest priority, and the last has the lowest. A gesture can activate only after all higher-priority gestures before it have failed."}),"\n",(0,o.jsxs)(n.p,{children:["For example, if you want to make a component that responds to single tap as well as to a double tap, you can accomplish that using ",(0,o.jsx)(n.code,{children:"useExclusiveGestures"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { StyleSheet, View } from 'react-native';\nimport {\n  GestureDetector,\n  GestureHandlerRootView,\n  useTapGesture,\n  useExclusiveGestures,\n} from 'react-native-gesture-handler';\n\nexport default function App() {\n  const singleTap = useTapGesture({\n    onDeactivate: (_, success) => {\n      if (success) {\n        console.log('Single tap!');\n      }\n    },\n  });\n\n  const doubleTap = useTapGesture({\n    numberOfTaps: 2,\n    onDeactivate: (_, success) => {\n      if (success) {\n        console.log('Double tap!');\n      }\n    },\n  });\n\n  const taps = useExclusiveGestures(doubleTap, singleTap);\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={taps}>\n        <View style={styles.box} />\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'space-around',\n  },\n  box: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'plum',\n  },\n});\n"})}),"\n",(0,o.jsx)(n.h2,{id:"cross-component-interactions",children:"Cross-component interactions"}),"\n",(0,o.jsx)(n.h3,{id:"requiretofail",children:"requireToFail"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"requireToFail"})," allows to delay activation of the handler until all handlers passed as arguments to this method fail (or don't begin at all)."]}),"\n",(0,o.jsx)(n.p,{children:"For example, you may want to have two nested components, both of them can be tapped by the user to trigger different actions: outer view requires one tap, but the inner one requires 2 taps. If you don't want the first tap on the inner view to activate the outer handler, you must make the outer gesture wait until the inner one fails:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport {\n  GestureDetector,\n  GestureHandlerRootView,\n  useTapGesture,\n} from 'react-native-gesture-handler';\n\nexport default function Example() {\n  const innerTap = useTapGesture({\n    numberOfTaps: 2,\n    onDeactivate: (_, success) => {\n      if (success) {\n        console.log('inner tap');\n      }\n    },\n  });\n\n  const outerTap = useTapGesture({\n    onDeactivate: (_, success) => {\n      if (success) {\n        console.log('outer tap');\n      }\n    },\n    requireToFail: innerTap,\n  });\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={outerTap}>\n        <View style={styles.outer}>\n          <GestureDetector gesture={innerTap}>\n            <View style={styles.inner} />\n          </GestureDetector>\n        </View>\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  outer: {\n    width: 250,\n    height: 250,\n    backgroundColor: 'lightblue',\n  },\n  inner: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    alignSelf: 'center',\n  },\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"block",children:"block"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"block"})," works similarly to ",(0,o.jsx)(n.code,{children:"requireToFail"})," but the direction of the relation is reversed - instead of being one-to-many relation, it's many-to-one. It's especially useful for making lists where the ",(0,o.jsx)(n.code,{children:"ScrollView"})," component needs to wait for every gesture underneath it. All that's required to do is to pass a ref, for example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import React, { useState } from 'react';\nimport { StyleSheet } from 'react-native';\nimport {\n  GestureDetector,\n  GestureHandlerRootView,\n  ScrollView,\n  NativeGesture,\n  usePinchGesture,\n} from 'react-native-gesture-handler';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n} from 'react-native-reanimated';\n\nconst ITEMS = ['red', 'green', 'blue', 'yellow'];\n\nexport default function Example() {\n  const [scrollGesture, setScrollGesture] = useState<NativeGesture | null>(\n    null\n  );\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <ScrollView\n        style={styles.container}\n        onGestureUpdate_CAN_CAUSE_INFINITE_RERENDER={(gesture) => {\n          if (!scrollGesture || scrollGesture.tag !== gesture.tag) {\n            setScrollGesture(gesture);\n          }\n        }}>\n        {ITEMS.map((item) => (\n          <Item\n            backgroundColor={item}\n            key={item}\n            scrollGesture={scrollGesture}\n          />\n        ))}\n      </ScrollView>\n    </GestureHandlerRootView>\n  );\n}\n\ntype ItemProps = {\n  backgroundColor: string;\n  scrollGesture: NativeGesture | null;\n};\n\nfunction Item({ backgroundColor, scrollGesture }: ItemProps) {\n  const scale = useSharedValue(1);\n  const zIndex = useSharedValue(1);\n\n  const pinch = usePinchGesture({\n    onBegin: () => {\n      zIndex.value = 100;\n    },\n    onUpdate: (e) => {\n      scale.value *= e.scaleChange;\n    },\n    onFinalize: () => {\n      scale.value = withTiming(1, undefined, (finished) => {\n        if (finished) {\n          zIndex.value = 1;\n        }\n      });\n    },\n    block: scrollGesture ?? undefined,\n  });\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n    zIndex: zIndex.value,\n  }));\n\n  return (\n    <GestureDetector gesture={pinch}>\n      <Animated.View\n        style={[\n          { backgroundColor: backgroundColor },\n          styles.item,\n          animatedStyles,\n        ]}\n      />\n    </GestureDetector>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  item: {\n    flex: 1,\n    aspectRatio: 1,\n  },\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"simultaneouswith",children:"simultaneousWith"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"simultaneousWith"})," allows gestures across different components to be recognized simultaneously. For example, you may want to have two nested views, both with tap gesture attached. Both of them require one tap, but tapping the inner one should also activate the gesture attached to the outer view:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport {\n  GestureDetector,\n  GestureHandlerRootView,\n  useTapGesture,\n} from 'react-native-gesture-handler';\n\nexport default function Example() {\n  const innerTap = useTapGesture({\n    onDeactivate: (_, success) => {\n      if (success) {\n        console.log('inner tap');\n      }\n    },\n  });\n\n  const outerTap = useTapGesture({\n    onDeactivate: (_, success) => {\n      if (success) {\n        console.log('outer tap');\n      }\n    },\n    simultaneousWith: innerTap,\n  });\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={outerTap}>\n        <View style={styles.outer}>\n          <GestureDetector gesture={innerTap}>\n            <View style={styles.inner} />\n          </GestureDetector>\n        </View>\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  outer: {\n    width: 250,\n    height: 250,\n    backgroundColor: 'lightblue',\n  },\n  inner: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    alignSelf: 'center',\n  },\n});\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(6540);const o={},r=s.createContext(o);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);