"use strict";(self.webpackChunkreact_native_gesture_handler_docs=self.webpackChunkreact_native_gesture_handler_docs||[]).push([[1301],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>g});var a=t(6540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(t),m=r,g=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return t?a.createElement(g,s(s({ref:n},c),{},{components:t})):a.createElement(g,s({ref:n},c))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[p]="string"==typeof e?e:r,s[1]=i;for(var u=2;u<o;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8055:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>u});var a=t(9668),r=(t(6540),t(5680));const o={id:"gesture-composition",title:"Gesture composition & interactions",sidebar_label:"Gesture composition & interactions",sidebar_position:4},s=void 0,i={unversionedId:"fundamentals/gesture-composition",id:"fundamentals/gesture-composition",title:"Gesture composition & interactions",description:"Composing gestures is much simpler in RNGH2, you don't need to create a ref for every gesture that depends on another one. Instead you can use Race, Simultaneous and Exclusive methods provided by the Gesture object.",source:"@site/docs/fundamentals/gesture-composition.md",sourceDirName:"fundamentals",slug:"/fundamentals/gesture-composition",permalink:"/react-native-gesture-handler/docs/fundamentals/gesture-composition",draft:!1,editUrl:"https://github.com/software-mansion/react-native-gesture-handler/edit/main/docs/docs/fundamentals/gesture-composition.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"gesture-composition",title:"Gesture composition & interactions",sidebar_label:"Gesture composition & interactions",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Quick start",permalink:"/react-native-gesture-handler/docs/fundamentals/quickstart/"},next:{title:"Manual gestures",permalink:"/react-native-gesture-handler/docs/fundamentals/manual-gestures/"}},l={},u=[{value:"Race",id:"race",level:2},{value:"Simultaneous",id:"simultaneous",level:2},{value:"Exclusive",id:"exclusive",level:2},{value:"requireExternalGestureToFail",id:"requireexternalgesturetofail",level:2},{value:"blocksExternalGesture",id:"blocksexternalgesture",level:2},{value:"simultaneousWithExternalGesture",id:"simultaneouswithexternalgesture",level:2}],c={toc:u},p="wrapper";function d(e){let{components:n,...t}=e;return(0,r.yg)(p,(0,a.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"Composing gestures is much simpler in RNGH2, you don't need to create a ref for every gesture that depends on another one. Instead you can use ",(0,r.yg)("inlineCode",{parentName:"p"},"Race"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"Simultaneous")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"Exclusive")," methods provided by the ",(0,r.yg)("inlineCode",{parentName:"p"},"Gesture")," object."),(0,r.yg)("h2",{id:"race"},"Race"),(0,r.yg)("p",null,"Only one of the provided gestures can become active at the same time. The first gesture to become active will cancel the rest of the gestures. It accepts variable number of arguments.\nIt is the equivalent to having more than one gesture handler without defining ",(0,r.yg)("inlineCode",{parentName:"p"},"simultaneousHandlers")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"waitFor")," props."),(0,r.yg)("p",null,"For example, lets say that you have a component that you want to make draggable but you also want to show additional options on long press. Presumably you would not want the component to move after the long press activates. You can accomplish this using ",(0,r.yg)("inlineCode",{parentName:"p"},"Race"),":"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},"Note: the ",(0,r.yg)("inlineCode",{parentName:"p"},"useSharedValue")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," are part of ",(0,r.yg)("a",{parentName:"p",href:"https://docs.swmansion.com/react-native-reanimated/"},(0,r.yg)("inlineCode",{parentName:"a"},"react-native-reanimated")),".")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"import { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n} from 'react-native-reanimated';\n\nfunction App() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n  const popupPosition = useSharedValue({ x: 0, y: 0 });\n  const popupAlpha = useSharedValue(0);\n\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n      ],\n    };\n  });\n\n  const animatedPopupStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: popupPosition.value.x },\n        { translateY: popupPosition.value.y },\n      ],\n      opacity: popupAlpha.value,\n    };\n  });\n\n  const dragGesture = Gesture.Pan()\n    .onStart((_e) => {\n      popupAlpha.value = withTiming(0);\n    })\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n    });\n\n  const longPressGesture = Gesture.LongPress().onStart((_event) => {\n    popupPosition.value = { x: offset.value.x, y: offset.value.y };\n    popupAlpha.value = withTiming(1);\n  });\n\n  const composed = Gesture.Race(dragGesture, longPressGesture);\n\n  return (\n    <Animated.View>\n      <Popup style={animatedPopupStyles} />\n      <GestureDetector gesture={composed}>\n        <Component style={animatedStyles} />\n      </GestureDetector>\n    </Animated.View>\n  );\n}\n")),(0,r.yg)("h2",{id:"simultaneous"},"Simultaneous"),(0,r.yg)("p",null,"All of the provided gestures can activate at the same time. Activation of one will not cancel the other.\nIt is the equivalent to having some gesture handlers, each with ",(0,r.yg)("inlineCode",{parentName:"p"},"simultaneousHandlers")," prop set to the other handlers."),(0,r.yg)("p",null,"For example, if you want to make a gallery app, you might want user to be able to zoom, rotate and pan around photos. You can do it with ",(0,r.yg)("inlineCode",{parentName:"p"},"Simultaneous"),":"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},"Note: the ",(0,r.yg)("inlineCode",{parentName:"p"},"useSharedValue")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," are part of ",(0,r.yg)("a",{parentName:"p",href:"https://docs.swmansion.com/react-native-reanimated/"},(0,r.yg)("inlineCode",{parentName:"a"},"react-native-reanimated")),".")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"import { GestureDetector, Gesture } from 'react-native-gesture-handler';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n} from 'react-native-reanimated';\n\nfunction App() {\n  const offset = useSharedValue({ x: 0, y: 0 });\n  const start = useSharedValue({ x: 0, y: 0 });\n  const scale = useSharedValue(1);\n  const savedScale = useSharedValue(1);\n  const rotation = useSharedValue(0);\n  const savedRotation = useSharedValue(0);\n  const animatedStyles = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: offset.value.x },\n        { translateY: offset.value.y },\n        { scale: scale.value },\n        { rotateZ: `${rotation.value}rad` },\n      ],\n    };\n  });\n\n  const dragGesture = Gesture.Pan()\n    .averageTouches(true)\n    .onUpdate((e) => {\n      offset.value = {\n        x: e.translationX + start.value.x,\n        y: e.translationY + start.value.y,\n      };\n    })\n    .onEnd(() => {\n      start.value = {\n        x: offset.value.x,\n        y: offset.value.y,\n      };\n    });\n\n  const zoomGesture = Gesture.Pinch()\n    .onUpdate((event) => {\n      scale.value = savedScale.value * event.scale;\n    })\n    .onEnd(() => {\n      savedScale.value = scale.value;\n    });\n\n  const rotateGesture = Gesture.Rotation()\n    .onUpdate((event) => {\n      rotation.value = savedRotation.value + event.rotation;\n    })\n    .onEnd(() => {\n      savedRotation.value = rotation.value;\n    });\n\n  const composed = Gesture.Simultaneous(\n    dragGesture,\n    Gesture.Simultaneous(zoomGesture, rotateGesture)\n  );\n\n  return (\n    <Animated.View>\n      <GestureDetector gesture={composed}>\n        <Photo style={animatedStyles} />\n      </GestureDetector>\n    </Animated.View>\n  );\n}\n")),(0,r.yg)("h2",{id:"exclusive"},"Exclusive"),(0,r.yg)("p",null,"Only one of the provided gestures can become active, with the first one having a higher priority than the second one (if both gestures are still possible, the second one will wait for the first one to fail before it activates), second one having a higher priority than the third one, and so on.\nIt is equivalent to having some gesture handlers where the second one has the ",(0,r.yg)("inlineCode",{parentName:"p"},"waitFor")," prop set to the first handler, third one has the ",(0,r.yg)("inlineCode",{parentName:"p"},"waitFor")," prop set to the first and the second one, and so on."),(0,r.yg)("p",null,"For example, if you want to make a component that responds to single tap as well as to a double tap, you can accomplish that using ",(0,r.yg)("inlineCode",{parentName:"p"},"Exclusive"),":"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},"Note: the ",(0,r.yg)("inlineCode",{parentName:"p"},"useSharedValue")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"useAnimatedStyle")," are part of ",(0,r.yg)("a",{parentName:"p",href:"https://docs.swmansion.com/react-native-reanimated/"},(0,r.yg)("inlineCode",{parentName:"a"},"react-native-reanimated")),".")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"import { GestureDetector, Gesture } from 'react-native-gesture-handler';\n\nfunction App() {\n  const singleTap = Gesture.Tap().onEnd((_event, success) => {\n    if (success) {\n      console.log('single tap!');\n    }\n  });\n  const doubleTap = Gesture.Tap()\n    .numberOfTaps(2)\n    .onEnd((_event, success) => {\n      if (success) {\n        console.log('double tap!');\n      }\n    });\n\n  const taps = Gesture.Exclusive(doubleTap, singleTap);\n\n  return (\n    <GestureDetector gesture={taps}>\n      <Component />\n    </GestureDetector>\n  );\n}\n")),(0,r.yg)("h1",{id:"cross-component-interactions"},"Cross-component interactions"),(0,r.yg)("p",null,"You may have noticed that gesture composition described above requires you to mount all of the composed gestures under a single ",(0,r.yg)("inlineCode",{parentName:"p"},"GestureDetector"),", effectively attaching them to the same underlying component. You can customize how gestures interact with each other across multiple components in a couple of ways:"),(0,r.yg)("h2",{id:"requireexternalgesturetofail"},"requireExternalGestureToFail"),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"requireExternalGestureToFail")," allows to delay activation of the handler until all handlers passed as arguments to this method fail (or don't begin at all)."),(0,r.yg)("p",null,"For example, you may want to have two nested components, both of them can be tapped by the user to trigger different actions: outer view requires one tap, but the inner one requires 2 taps. If you don't want the first tap on the inner view to activate the outer handler, you must make the outer gesture wait until the inner one fails:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport {\n  GestureDetector,\n  Gesture,\n  GestureHandlerRootView,\n} from 'react-native-gesture-handler';\n\nexport default function Example() {\n  const innerTap = Gesture.Tap()\n    .numberOfTaps(2)\n    .onStart(() => {\n      console.log('inner tap');\n    });\n\n  const outerTap = Gesture.Tap()\n    .onStart(() => {\n      console.log('outer tap');\n    })\n    .requireExternalGestureToFail(innerTap);\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={outerTap}>\n        <View style={styles.outer}>\n          <GestureDetector gesture={innerTap}>\n            <View style={styles.inner} />\n          </GestureDetector>\n        </View>\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  outer: {\n    width: 250,\n    height: 250,\n    backgroundColor: 'lightblue',\n  },\n  inner: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    alignSelf: 'center',\n  },\n});\n")),(0,r.yg)("h2",{id:"blocksexternalgesture"},"blocksExternalGesture"),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"blocksExternalGesture")," works similarly to ",(0,r.yg)("inlineCode",{parentName:"p"},"requireExternalGestureToFail")," but the direction of the relation is reversed - instead of being one-to-many relation, it's many-to-one. It's especially useful for making lists where the ",(0,r.yg)("inlineCode",{parentName:"p"},"ScrollView")," component needs to wait for every gesture underneath it. All that's required to do is to pass a ref, for example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-jsx"},"import React, { useRef } from 'react';\nimport { StyleSheet } from 'react-native';\nimport {\n  GestureDetector,\n  Gesture,\n  GestureHandlerRootView,\n  ScrollView,\n} from 'react-native-gesture-handler';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n} from 'react-native-reanimated';\n\nconst ITEMS = ['red', 'green', 'blue', 'yellow'];\n\nfunction Item({ backgroundColor, scrollRef }) {\n  const scale = useSharedValue(1);\n  const zIndex = useSharedValue(1);\n\n  const pinch = Gesture.Pinch()\n    .blocksExternalGesture(scrollRef)\n    .onBegin(() => {\n      zIndex.value = 100;\n    })\n    .onChange((e) => {\n      scale.value *= e.scaleChange;\n    })\n    .onFinalize(() => {\n      scale.value = withTiming(1, undefined, (finished) => {\n        if (finished) {\n          zIndex.value = 1;\n        }\n      });\n    });\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n    zIndex: zIndex.value,\n  }));\n\n  return (\n    <GestureDetector gesture={pinch}>\n      <Animated.View\n        style={[\n          { backgroundColor: backgroundColor },\n          styles.item,\n          animatedStyles,\n        ]}\n      />\n    </GestureDetector>\n  );\n}\n\nexport default function Example() {\n  const scrollRef = useRef();\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <ScrollView style={styles.container} ref={scrollRef}>\n        {ITEMS.map((item) => (\n          <Item backgroundColor={item} key={item} scrollRef={scrollRef} />\n        ))}\n      </ScrollView>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  item: {\n    flex: 1,\n    aspectRatio: 1,\n  },\n});\n")),(0,r.yg)("h2",{id:"simultaneouswithexternalgesture"},"simultaneousWithExternalGesture"),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"simultaneousWithExternalGesture")," allows gestures across different components to be recognized simultaneously. For example, you may want to have two nested views, both with tap gesture attached. Both of them require one tap, but tapping the inner one should also activate the gesture attached to the outer view:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport {\n  GestureDetector,\n  Gesture,\n  GestureHandlerRootView,\n} from 'react-native-gesture-handler';\n\nexport default function Example() {\n  const innerTap = Gesture.Tap()\n    .onStart(() => {\n      console.log('inner tap');\n    });\n\n  const outerTap = Gesture.Tap()\n    .onStart(() => {\n      console.log('outer tap');\n    })\n    .simultaneousWithExternalGesture(innerTap);\n\n  return (\n    <GestureHandlerRootView style={styles.container}>\n      <GestureDetector gesture={outerTap}>\n        <View style={styles.outer}>\n          <GestureDetector gesture={innerTap}>\n            <View style={styles.inner} />\n          </GestureDetector>\n        </View>\n      </GestureDetector>\n    </GestureHandlerRootView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  outer: {\n    width: 250,\n    height: 250,\n    backgroundColor: 'lightblue',\n  },\n  inner: {\n    width: 100,\n    height: 100,\n    backgroundColor: 'blue',\n    alignSelf: 'center',\n  },\n});\n")))}d.isMDXComponent=!0}}]);