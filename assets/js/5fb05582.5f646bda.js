"use strict";(self.webpackChunkreact_native_gesture_handler_docs=self.webpackChunkreact_native_gesture_handler_docs||[]).push([[5376],{450:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"fundamentals/root-view","title":"GestureHandlerRootView","description":"GestureHandlerRootView is a key component that enables Gesture Handler to intercept touch events, allowing for the implementation of gestures in your app. It should wrap your app\'s main component, and any component that relies on Gesture Handler\'s gestures has to be a descendant of this view. For more detailed information, you can check out the under-the-hood section.","source":"@site/docs/fundamentals/root-view.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/root-view","permalink":"/react-native-gesture-handler/docs/fundamentals/root-view","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-gesture-handler/edit/main/packages/docs-gesture-handler/docs/fundamentals/root-view.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"root-view","title":"GestureHandlerRootView","sidebar_label":"GestureHandlerRootView","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Installation","permalink":"/react-native-gesture-handler/docs/fundamentals/installation"},"next":{"title":"Gesture detectors","permalink":"/react-native-gesture-handler/docs/fundamentals/gesture-detectors"}}');var r=n(4848),s=n(8453);const i={id:"root-view",title:"GestureHandlerRootView",sidebar_label:"GestureHandlerRootView",sidebar_position:3},a=void 0,d={},l=[{value:"Styling",id:"styling",level:2},{value:"Nesting root views",id:"nesting-root-views",level:2},{value:"unstable_forceActive",id:"unstable_forceactive",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"GestureHandlerRootView"})," is a key component that enables Gesture Handler to intercept touch events, allowing for the implementation of gestures in your app. It should wrap your app's main component, and any component that relies on Gesture Handler's gestures has to be a descendant of this view. For more detailed information, you can check out the ",(0,r.jsx)(t.a,{href:"/docs/under-the-hood/how-does-it-work#android",children:"under-the-hood section"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:"import { GestureHandlerRootView } from 'react-native-gesture-handler';\n\nexport default function App() {\n  return (\n    <GestureHandlerRootView>\n      <ActualApp />\n    </GestureHandlerRootView>\n  );\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Keep ",(0,r.jsx)(t.code,{children:"GestureHandlerRootView"})," as close to the actual root of the app as possible. It's the entry point for all gestures and all ",(0,r.jsx)(t.a,{href:"/docs/fundamentals/gesture-composition",children:"gesture relations"}),". The gestures won't be recognized outside of the root view, and relations only work between gestures mounted under the same root view."]}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["When integrating with navigation libraries, wrapping the navigator component with ",(0,r.jsx)(t.code,{children:"GestureHandlerRootView"})," is generally sufficient. However, if you encounter issues with gestures not functioning properly, you might need to wrap each individual screen component with ",(0,r.jsx)(t.code,{children:"GestureHandlerRootView"})," as well."]})}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["If you're using Gesture Handler in your component library, you may want to wrap your library's code in the ",(0,r.jsx)(t.code,{children:"GestureHandlerRootView"})," component. This will avoid extra configuration for the user."]})}),"\n",(0,r.jsx)(t.h2,{id:"styling",children:"Styling"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"GestureHandlerRootView"})," can be thought of as a regular ",(0,r.jsx)(t.code,{children:"View"})," component, therefore it accepts all the same props, including ",(0,r.jsx)(t.a,{href:"https://reactnative.dev/docs/0.81/view-style-props",children:(0,r.jsx)(t.code,{children:"style"})}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["If you don't provide anything to the ",(0,r.jsx)(t.code,{children:"style"})," prop, it will default to ",(0,r.jsx)(t.code,{children:"{ flex: 1 }"}),". If you want to customize the styling of the root view, don't forget to also include ",(0,r.jsx)(t.code,{children:"flex: 1"})," in the custom style, otherwise your app won't render anything."]}),"\n",(0,r.jsx)(t.h2,{id:"nesting-root-views",children:"Nesting root views"}),"\n",(0,r.jsxs)(t.p,{children:["In case of nested root views, Gesture Handler will only use the top-most one and ignore the nested ones. If you're unsure if one of your dependencies already renders ",(0,r.jsx)(t.code,{children:"GestureHandlerRootView"})," on its own, don't worry and add one at the root anyway."]}),"\n",(0,r.jsx)(t.h2,{id:"unstable_forceactive",children:"unstable_forceActive"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"unstable_forceActive?: boolean;\n"})}),"\n",(0,r.jsxs)(t.p,{children:["If you're having trouble with gestures not working when inside a component provided by a third-party library, even though you've wrapped the entry point with ",(0,r.jsx)(t.code,{children:"<GestureHandlerRootView>"}),", you can try adding another ",(0,r.jsx)(t.code,{children:"<GestureHandlerRootView unstable_forceActive>"})," closer to the place the gestures are defined. This way, you can prevent Android from canceling relevant gestures when one of the native views tries to grab lock for delivering touch events."]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(6540);const r={},s=o.createContext(r);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);