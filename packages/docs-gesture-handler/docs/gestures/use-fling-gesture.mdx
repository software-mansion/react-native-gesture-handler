---
id: use-fling-gesture
title: Fling gesture
sidebar_label: Fling gesture
sidebar_position: 6
---

import { vanishOnMobile, appearOnMobile, webContainer } from '@site/src/utils/getGestureStyles';

import useBaseUrl from '@docusaurus/useBaseUrl';

import FlingGestureBasic from '@site/static/examples/FlingGestureBasic';
import FlingGestureBasicSrc from '!!raw-loader!@site/static/examples/FlingGestureBasicSrc';

<div className={webContainer}>
  <div className={vanishOnMobile} style={{ display: 'flex', justifyContent: 'center', maxWidth: 360 }}>
    <video playsInline autoPlay muted loop style={{maxWidth: 360}}>
      <source src={useBaseUrl("/video/fling.mp4")} type="video/mp4"/>
    </video>
  </div>
  <InteractiveExample
    component={<FlingGestureBasic/>}
    src={FlingGestureBasicSrc}
    disableMarginBottom={true}
  />
</div>

import BaseEventData from './\_shared/base-gesture-event-data.mdx';
import BaseGestureConfig from './\_shared/base-gesture-config.mdx';
import BaseGestureCallbacks from './\_shared/base-gesture-callbacks.mdx';
import SharedValueInfo from './\_shared/shared-value-info.md';

The gesture that tracks quick, sufficiently long movement in specified [direction](#direction).
When gesture gets activated it will end when finger is released.
The gesture will fail if the finger is lifted before gesture could activate.

  <div className={appearOnMobile} style={{ display: 'flex', justifyContent: 'center' }}>
    <video playsInline autoPlay muted loop style={{maxWidth: 360}}>
      <source src={useBaseUrl("/video/fling.mp4")} type="video/mp4"/>
    </video>
  </div>

## Example

<CollapsibleCode
label="Show full example"
expandedLabel="Hide full example"
lineBounds={[13, 34]}
src={`
import { StyleSheet } from 'react-native';
import {
  GestureDetector,
  GestureHandlerRootView,
  Directions,
  useFlingGesture,
} from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
} from 'react-native-reanimated';

export default function App() {
  const position = useSharedValue(0);

  const flingGesture = useFlingGesture({
    direction: Directions.RIGHT,
    onActivate: () => {
      position.value = withTiming(position.value + 10, { duration: 100 });
    },
  });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: position.value }],
  }));

  return (
    <GestureHandlerRootView style={styles.container}>
      <GestureDetector gesture={flingGesture}>
        <Animated.View style={[styles.box, animatedStyle]} />
      </GestureDetector>
    </GestureHandlerRootView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'space-around',
  },
  box: {
    height: 120,
    width: 120,
    backgroundColor: '#b58df1',
    borderRadius: 20,
    marginBottom: 30,
  },
});
`}/>

## Config

<SharedValueInfo />

### direction

<CollapsibleCode 
label="Show composed types definitions"
expandedLabel="Hide composed types definitions"
lineBounds={[0, 1]}
src={`
direction: Directions | SharedValue<Directions>;

export const Directions = {
  RIGHT: 1,
  LEFT: 2,
  UP: 4,
  DOWN: 8,
} as const;
`}/>

Expressed allowed direction of movement. Expected values are exported as constants in the `Directions` object. It's possible to combine directions using `|` operator.

```js
import { Directions } from 'react-native-gesture-handler';

// Single direction
const fling = useFlingGesture({ direction: Directions.RIGHT });

// Combined directions
const fling = useFlingGesture({ direction: Directions.RIGHT | Directions.LEFT });
```

### numberOfPointers

```ts
numberOfPointers: number | SharedValue<number>;
```

Determine exact number of points required to handle the fling gesture.

### mouseButton (Web & Android only)

<CollapsibleCode 
label="Show composed types definitions"
expandedLabel="Hide composed types definitions"
lineBounds={[0, 1]}
collapsed={false}
src={`
mouseButton: MouseButton | SharedValue<MouseButton>;

enum MouseButton {
  LEFT,
  RIGHT,
  MIDDLE,
  BUTTON_4,
  BUTTON_5,
  ALL,
}
`}/>

Allows users to choose which mouse button should handler respond to. Arguments can be combined using `|` operator, e.g. `mouseButton(MouseButton.LEFT | MouseButton.RIGHT)`. Default value is set to `MouseButton.LEFT`.

<BaseGestureConfig />

## Callbacks

<BaseGestureCallbacks gesture={"Fling"}/>

## Event data

### x

```ts
x: number;
```

X coordinate of the current position of the pointer (finger or a leading pointer when there are multiple fingers placed) relative to the view attached to the [`GestureDetector`](/docs/fundamentals/gesture-detectors#gesture-detector). Expressed in point units.

### y

```ts
y: number;
```

Y coordinate of the current position of the pointer (finger or a leading pointer when there are multiple fingers placed) relative to the view attached to the [`GestureDetector`](/docs/fundamentals/gesture-detectors#gesture-detector). Expressed in point units.

### absoluteX

```ts
absoluteX: number;
```

X coordinate of the current position of the pointer (finger or a leading pointer when there are multiple fingers placed) relative to the window. The value is expressed in point units. It is recommended to use it instead of [`x`](#x) in cases when the original view can be transformed as an effect of the gesture.

### absoluteY

```ts
absoluteY: number;
```

Y coordinate of the current position of the pointer (finger or a leading pointer when there are multiple fingers placed) relative to the window. The value is expressed in point units. It is recommended to use it instead of [`y`](#y) in cases when the original view can be transformed as an effect of the gesture.

<BaseEventData />
